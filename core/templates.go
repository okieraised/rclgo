package core

import "C"
import (
	"strings"
	"text/template"

	"github.com/okieraised/rclgo/core/internal/utilities"
)

var templateFuncMap template.FuncMap = template.FuncMap{
	"lc":                          strings.ToLower,
	"camelToSnake":                utilities.CamelToSnake,
	"defaultCode":                 defaultCode,
	"ucFirst":                     utilities.UpperCaseFirst,
	"srvNameFromSrvMsgName":       utilities.SrvNameFromSrvMsgName,
	"actionNameFromActionMsgName": utilities.ActionNameFromActionMsgName,
	"actionNameFromActionSrvName": utilities.ActionNameFromActionSrvName,
	"cReturnCodeNameToGo":         utilities.CReturnCodeNameToGo,
	"cloneCode":                   cloneCode,
	"actionHasSuffix":             actionHasSuffix,
	"matchMsg":                    matchMsg,
	"sanitizeValue":               utilities.DefaultValueSanitizer,
	"goLicenseHeader":             utilities.LicenseHeader,
}

var ros2PackageCommonTemplate = template.Must(
	template.New("ros2PackageCommonTemplate").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.

package {{ .GoPackage }}

/*
{{range $dir := .Config.RootPaths -}}
#cgo LDFLAGS: "-L{{$dir}}/lib" "-Wl,-rpath={{$dir}}/lib"
{{end}}
#cgo LDFLAGS: -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -l{{.CPackage}}__rosidl_typesupport_c -l{{.CPackage}}__rosidl_generator_c
{{range $k, $v := .CImports -}}
#cgo LDFLAGS: -l{{$k}}__rosidl_typesupport_c -l{{$k}}__rosidl_generator_c
{{""}}
{{- end -}}
{{range $dir := .Config.RootPaths}}
#cgo CFLAGS: "-I{{$dir}}/include/action_msgs"
#cgo CFLAGS: "-I{{$dir}}/include/builtin_interfaces"
#cgo CFLAGS: "-I{{$dir}}/include/example_interfaces"
#cgo CFLAGS: "-I{{$dir}}/include/geometry_msgs"
#cgo CFLAGS: "-I{{$dir}}/include/rosidl_runtime_c"
#cgo CFLAGS: "-I{{$dir}}/include/rosidl_typesupport_interface"
#cgo CFLAGS: "-I{{$dir}}/include/sensor_msgs"
#cgo CFLAGS: "-I{{$dir}}/include/std_msgs"
#cgo CFLAGS: "-I{{$dir}}/include/std_srvs"
#cgo CFLAGS: "-I{{$dir}}/include/test_msgs"
#cgo CFLAGS: "-I{{$dir}}/include/unique_identifier_msgs"
{{- range $k, $v := $.CImports}}
#cgo CFLAGS: "-I{{$dir}}/include/{{$k}}"
{{end}}
#cgo CFLAGS: "-I{{$dir}}/include/{{$.CPackage}}"
{{end -}}
*/
import "C"
`,
	),
)

var ros2MsgToGolangTypeTemplate = template.Must(
	template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.
{{ $Md := .Message }}
package {{ $Md.GoPackage }}
import (
	"unsafe"

	"{{.Config.RclgoImportPath}}"
	{{range $path, $name := $Md.GoImports -}}
	{{$name}} "{{$path}}"
	{{""}}{{- end}}
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>
{{if eq $Md.Type "msg"}}
#include <{{$Md.Package}}/msg/{{$Md.Name | camelToSnake}}.h>
{{else if eq $Md.Type "srv"}}
#include <{{$Md.Package}}/srv/{{$Md.Name | srvNameFromSrvMsgName | camelToSnake}}.h>
{{else if eq $Md.Type "action"}}
#include <{{$Md.Package}}/action/{{$Md.Name | actionNameFromActionMsgName | camelToSnake}}.h>
{{end}}
*/
import "C"

func init() {
	{{ $.ROSDistro }}.RegisterMessage("{{$Md.Package}}/{{$Md.Name}}", {{$Md.Name}}TypeSupport)
	{{ $.ROSDistro }}.RegisterMessage("{{$Md.Package}}/{{$Md.Type}}/{{$Md.Name}}", {{$Md.Name}}TypeSupport)
}

{{- if $Md.Constants }}
const (
{{- range $Md.Constants }}
	{{$Md.Name}}_{{.RosName}} {{.GoPkgReference}}{{.GoType}} = {{sanitizeValue .RosType .Value}}{{if .Comment -}} // {{.Comment}}{{- end}}
{{- end }}
)
{{- end }}

type {{$Md.Name}} struct {
	{{- range $k, $v := $Md.Fields }}
	{{$v.GoName }} {{$v.TypeArray}}{{$v.GoPkgReference}}{{$v.GoType}}` +
			"{{\"\"}} `yaml:\"{{$v.RosName}}\"`" + `{{if .Comment -}} // {{.Comment}}{{- end}}
	{{- end }}
}

// New{{$Md.Name}} creates a new {{$Md.Name}} with default values.
func New{{$Md.Name}}() *{{$Md.Name}} {
	self := {{$Md.Name}}{}
	self.SetDefaults()
	return &self
}

func (t *{{$Md.Name}}) Clone() *{{$Md.Name}} {
	c := &{{$Md.Name}}{}
	{{- range $f := $Md.Fields }}
	{{cloneCode $f}}
	{{- end }}
	return c
}

func (t *{{$Md.Name}}) CloneMsg() {{ $.ROSDistro }}.Message {
	return t.Clone()
}

func (t *{{$Md.Name}}) SetDefaults() {
	{{- range $k, $v := $Md.Fields }}
	{{defaultCode $v}}
	{{- end }}
}

func (t *{{$Md.Name}}) GetTypeSupport() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{$Md.Name}}TypeSupport
}

{{- /* Some special cased methods to avoid cyclic dependency in actions */ -}}

{{- if actionHasSuffix $Md 
	"_SendGoal_Request"
	"_GetResult_Request"
	"_CancelGoal_Request"
	"_FeedbackMessage"
}}
func (t *{{$Md.Name}}) GetGoalID() *{{ $.ROSDistro }}.GoalID {
	return (*{{ $.ROSDistro }}.GoalID)(&t.GoalID.Uuid)
}

func (t *{{$Md.Name}}) SetGoalID(id *{{ $.ROSDistro }}.GoalID) {
	t.GoalID.Uuid = *id
}
{{- end -}}

{{- if actionHasSuffix $Md "_SendGoal_Request" }}
func (t *{{$Md.Name}}) GetGoalDescription() {{ $.ROSDistro }}.Message {
	return &t.Goal
}

func (t *{{$Md.Name}}) SetGoalDescription(desc {{ $.ROSDistro }}.Message) {
	t.Goal = *desc.(*{{$Md.Name | actionNameFromActionMsgName}}_Goal)
}
{{- end -}}

{{- if actionHasSuffix $Md "_SendGoal_Response" }}
func (t *{{$Md.Name}}) GetGoalAccepted() bool {
	return t.Accepted
}
{{- end -}}

{{ if matchMsg $Md "action_msgs_srv" "CancelGoal_Request" }}
func (t *{{$Md.Name}}) GetGoalID() *{{ $.ROSDistro }}.GoalID {
	return (*{{ $.ROSDistro }}.GoalID)(&t.GoalInfo.GoalId.Uuid)
}

func (t *{{$Md.Name}}) SetGoalID(id *{{ $.ROSDistro }}.GoalID) {
	t.GoalInfo.GoalId.Uuid = *id
}
{{- else if matchMsg $Md "action_msgs_srv" "CancelGoal_Response" }}
func (t *{{$Md.Name}}) CallForEach(f func(interface{})) {
	for i := range t.GoalsCanceling {
		f((*{{ $.ROSDistro }}.GoalID)(&t.GoalsCanceling[i].GoalId.Uuid))
	}
}
{{- else if matchMsg $Md "action_msgs_msg" "GoalStatus" }}
func (t *{{$Md.Name}}) GetGoalID() *{{ $.ROSDistro }}.GoalID {
	return (*{{ $.ROSDistro }}.GoalID)(&t.GoalInfo.GoalId.Uuid)
}

func (t *{{$Md.Name}}) SetGoalID(id *{{ $.ROSDistro }}.GoalID) {
	t.GoalInfo.GoalId.Uuid = *id
}
{{- else if matchMsg $Md "action_msgs_msg" "GoalStatusArray" }}
func (t *{{$Md.Name}}) CallForEach(f func(interface{})) {
	for i := range t.StatusList {
		f(&t.StatusList[i])
	}
}
{{- end }}

// {{$Md.Name}}Publisher wraps {{ $.ROSDistro }}.Publisher to provide type safe helper
// functions
type {{$Md.Name}}Publisher struct {
	*{{ $.ROSDistro }}.Publisher
}

// New{{$Md.Name}}Publisher creates and returns a new publisher for the
// {{$Md.Name}}
func New{{$Md.Name}}Publisher(node *{{ $.ROSDistro }}.Node, topicName string, options *{{ $.ROSDistro }}.PublisherOptions) (*{{$Md.Name}}Publisher, error) {
	pub, err := node.NewPublisher(topicName, {{$Md.Name}}TypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &{{$Md.Name}}Publisher{pub}, nil
}

func (p *{{$Md.Name}}Publisher) Publish(msg *{{$Md.Name}}) error {
	return p.Publisher.Publish(msg)
}

// {{$Md.Name}}Subscription wraps {{ $.ROSDistro }}.Subscription to provide type safe helper
// functions
type {{$Md.Name}}Subscription struct {
	*{{ $.ROSDistro }}.Subscription
}

// {{$Md.Name}}SubscriptionCallback type is used to provide a subscription
// handler function for a {{$Md.Name}}Subscription.
type {{$Md.Name}}SubscriptionCallback func(msg *{{$Md.Name}}, info *{{ $.ROSDistro }}.MessageInfo, err error)

// New{{$Md.Name}}Subscription creates and returns a new subscription for the
// {{$Md.Name}}
func New{{$Md.Name}}Subscription(node *{{ $.ROSDistro }}.Node, topicName string, opts *{{ $.ROSDistro }}.SubscriptionOptions, subscriptionCallback {{$Md.Name}}SubscriptionCallback) (*{{$Md.Name}}Subscription, error) {
	callback := func(s *{{ $.ROSDistro }}.Subscription) {
		var msg {{$Md.Name}}
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topicName, {{$Md.Name}}TypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &{{$Md.Name}}Subscription{sub}, nil
}

func (s *{{$Md.Name}}Subscription) TakeMessage(out *{{$Md.Name}}) (*{{ $.ROSDistro }}.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// Clone{{$Md.Name}}Slice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func Clone{{$Md.Name}}Slice(dst, src []{{$Md.Name}}) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var {{$Md.Name}}TypeSupport {{ $.ROSDistro }}.MessageTypeSupport = _{{$Md.Name}}TypeSupport{}

type _{{$Md.Name}}TypeSupport struct{}

func (t _{{$Md.Name}}TypeSupport) New() {{ $.ROSDistro }}.Message {
	return New{{$Md.Name}}()
}

func (t _{{$Md.Name}}TypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
	return (unsafe.Pointer)(C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__create())
}

func (t _{{$Md.Name}}TypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__destroy((*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(pointer_to_free))
}

func (t _{{$Md.Name}}TypeSupport) AsCStruct(dst unsafe.Pointer, msg {{ $.ROSDistro }}.Message) {
	{{ if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(dst)
	{{- range $Md.Fields }}
	{{call $.cSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) AsGoStruct(msg {{ $.ROSDistro }}.Message, ros2_message_buffer unsafe.Pointer) {
	{{if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(ros2_message_buffer)
	{{- range $Md.Fields }}
	{{call $.goSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}())
}

type C{{$Md.Name}} = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
type C{{$Md.Name}}Sequence = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__Sequence

func {{$Md.Name}}SequenceToGo(goSlice *[]{{$Md.Name}}, cSlice C{{$Md.Name}}Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{$Md.Name}}, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		{{$Md.Name}}TypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func {{$Md.Name}}SequenceToC(cSlice *C{{$Md.Name}}Sequence, goSlice []{{$Md.Name}}) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(C.malloc(C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}

func {{$Md.Name}}ArrayToGo(goSlice []{{$Md.Name}}, cSlice []C{{$Md.Name}}) {
	for i := 0; i < len(cSlice); i++ {
		{{$Md.Name}}TypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func {{$Md.Name}}ArrayToC(cSlice []C{{$Md.Name}}, goSlice []{{$Md.Name}}) {
	for i := 0; i < len(goSlice); i++ {
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
`),
)

var ros2ServiceToGolangTypeTemplate = template.Must(
	template.New("ros2ServiceToGolangTypeTemplate").
		Funcs(templateFuncMap).
		Parse(
			`// Code generated by ros2gen. DO NOT EDIT.

package {{ .Service.GoPackage }}

/*
#include <rosidl_runtime_c/message_type_support_struct.h>
{{- if eq .Service.Type "action"}}
#include <{{.Service.Package}}/action/{{.Service.Name | actionNameFromActionSrvName | camelToSnake}}.h>
{{- else}}
#include <{{.Service.Package}}/srv/{{.Service.Name | camelToSnake}}.h>
{{- end}}
*/
import "C"

import (
	"context"
	"errors"
	"unsafe"

	"{{.Config.RclgoImportPath}}"
)

func init() {
	{{ $.ROSDistro }}.RegisterService("{{.Service.Package}}/{{.Service.Name}}", {{ .Service.Name }}TypeSupport)
	{{ $.ROSDistro }}.RegisterService("{{.Service.Package}}/{{.Service.Type}}/{{.Service.Name}}", {{ .Service.Name }}TypeSupport)
}

type _{{.Service.Name}}TypeSupport struct {}

func (s _{{.Service.Name}}TypeSupport) Request() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Service.Request.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) Response() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Service.Response.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_service_type_support_handle__{{.Service.Package}}__{{.Service.Type}}__{{.Service.Name}}())
}

// Modifying this variable is undefined behavior.
var {{ .Service.Name }}TypeSupport {{ $.ROSDistro }}.ServiceTypeSupport = _{{.Service.Name}}TypeSupport{}

// {{.Service.Name}}Client wraps {{ $.ROSDistro }}.Client to provide type safe helper
// functions
type {{.Service.Name}}Client struct {
	*{{ $.ROSDistro }}.Client
}

// New{{.Service.Name}}Client creates and returns a new client for the
// {{.Service.Name}}
func New{{.Service.Name}}Client(node *{{ $.ROSDistro }}.Node, serviceName string, options *{{ $.ROSDistro }}.ClientOptions) (*{{.Service.Name}}Client, error) {
	client, err := node.NewClient(serviceName, {{.Service.Name}}TypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &{{.Service.Name}}Client{client}, nil
}

func (s *{{.Service.Name}}Client) Send(ctx context.Context, req *{{.Service.Request.Name}}) (*{{.Service.Response.Name}}, *{{ $.ROSDistro }}.ServiceInfo, error) {
	msg, rmw, err := s.Client.Send(ctx, req)
	if err != nil {
		return nil, rmw, err
	}
	typedMessage, ok := msg.(*{{.Service.Response.Name}})
	if !ok {
		return nil, rmw, errors.New("invalid message type returned")
	}
	return typedMessage, rmw, err
}

type {{.Service.Name}}ServiceResponseSender struct {
	sender {{ $.ROSDistro }}.ServiceResponseSender
}

func (s {{.Service.Name}}ServiceResponseSender) SendResponse(resp *{{.Service.Response.Name}}) error {
	return s.sender.SendResponse(resp)
}

type {{.Service.Name}}ServiceRequestHandler func(*{{ $.ROSDistro }}.ServiceInfo, *{{.Service.Request.Name}}, {{.Service.Name}}ServiceResponseSender)

// {{.Service.Name}}Service wraps {{ $.ROSDistro }}.Service to provide type safe helper
// functions
type {{.Service.Name}}Service struct {
	*{{ $.ROSDistro }}.Service
}

// New{{.Service.Name}}Service creates and returns a new service for the
// {{.Service.Name}}
func New{{.Service.Name}}Service(node *{{ $.ROSDistro }}.Node, name string, options *{{ $.ROSDistro }}.ServiceOptions, handler {{.Service.Name}}ServiceRequestHandler) (*{{.Service.Name}}Service, error) {
	h := func(rmw *{{ $.ROSDistro }}.ServiceInfo, msg {{ $.ROSDistro }}.Message, rs {{ $.ROSDistro }}.ServiceResponseSender) {
		m := msg.(*{{.Service.Request.Name}})
		responseSender := {{.Service.Name}}ServiceResponseSender{sender: rs} 
		handler(rmw, m, responseSender)
	}
	service, err := node.NewService(name, {{.Service.Name}}TypeSupport, options, h)
	if err != nil {
		return nil, err
	}
	return &{{.Service.Name}}Service{service}, nil
}`),
)

var ros2ActionToGolangTypeTemplate = template.Must(
	template.New("ros2ServiceToGolangTypeTemplate").
		Funcs(templateFuncMap).
		Parse(
			`// Code generated by ros2gen. DO NOT EDIT.

package {{ .Action.GoPackage }}

/*
#include <rosidl_runtime_c/message_type_support_struct.h>
#include <{{.Action.Package}}/action/{{.Action.Name | actionNameFromActionSrvName | camelToSnake}}.h>
*/
import "C"

import (
	"context"
	"time"
	"unsafe"

	"{{.Config.RclgoImportPath}}"

	action_msgs_msg "{{.Config.MessageModulePrefix}}/action_msgs/msg"
	action_msgs_srv "{{.Config.MessageModulePrefix}}/action_msgs/srv"
)

func init() {
	{{ $.ROSDistro }}.RegisterAction("{{.Action.Package}}/{{.Action.Name}}", {{ .Action.Name }}TypeSupport)
	{{ $.ROSDistro }}.RegisterAction("{{.Action.Package}}/{{.Action.Type}}/{{.Action.Name}}", {{ .Action.Name }}TypeSupport)
}

type _{{.Action.Name}}TypeSupport struct {}

func (s _{{.Action.Name}}TypeSupport) Goal() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Action.Goal.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) SendGoal() {{ $.ROSDistro }}.ServiceTypeSupport {
	return {{.Action.SendGoal.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) NewSendGoalResponse(accepted bool, stamp time.Duration) {{ $.ROSDistro }}.Message {
	msg := New{{.Action.Name}}_SendGoal_Response()
	msg.Accepted = accepted
	secs := stamp.Truncate(time.Second)
	msg.Stamp.Sec = int32(secs)
	msg.Stamp.Nanosec = uint32(stamp - secs)
	return msg
}

func (s _{{.Action.Name}}TypeSupport) Result() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Action.Result.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) GetResult() {{ $.ROSDistro }}.ServiceTypeSupport {
	return {{.Action.GetResult.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) NewGetResultResponse(status int8, result types.Message) {{ $.ROSDistro }}.Message {
	msg := New{{.Action.Name}}_GetResult_Response()
	msg.Status = status
	if result == nil {
		msg.Result = *New{{.Action.Name}}_Result()
	} else {
		msg.Result = *result.(*{{.Action.Name}}_Result)
	}
	return msg
}

func (s _{{.Action.Name}}TypeSupport) CancelGoal() {{ $.ROSDistro }}.ServiceTypeSupport {
	return action_msgs_srv.CancelGoalTypeSupport
}

func (s _{{.Action.Name}}TypeSupport) Feedback() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Action.Feedback.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) FeedbackMessage() {{ $.ROSDistro }}.MessageTypeSupport {
	return {{.Action.FeedbackMessage.Name}}TypeSupport
}

func (s _{{.Action.Name}}TypeSupport) NewFeedbackMessage(goalID *{{ $.ROSDistro }}.GoalID, feedback {{ $.ROSDistro }}.Message) {{ $.ROSDistro }}.Message {
	msg := New{{.Action.Name}}_FeedbackMessage()
	msg.GoalID.Uuid = *goalID
	msg.Feedback = *feedback.(*{{.Action.Name}}_Feedback)
	return msg
}

func (s _{{.Action.Name}}TypeSupport) GoalStatusArray() {{ $.ROSDistro }}.MessageTypeSupport {
	return action_msgs_msg.GoalStatusArrayTypeSupport
}

func (s _{{.Action.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_action_type_support_handle__{{.Action.Package}}__{{.Action.Type}}__{{.Action.Name}}())
}

// Modifying this variable is undefined behavior.
var {{.Action.Name}}TypeSupport {{ $.ROSDistro }}.ActionTypeSupport = _{{.Action.Name}}TypeSupport{}

type {{.Action.Name}}FeedbackSender struct {
	sender {{ $.ROSDistro }}.FeedbackSender
}

func (s *{{.Action.Name}}FeedbackSender) Send(msg *{{.Action.Name}}_Feedback) error {
	return s.sender.Send(msg)
}

type {{.Action.Name}}GoalHandle struct{
	*{{ $.ROSDistro }}.GoalHandle

	Description *{{.Action.Name}}_Goal
}

func (g *{{.Action.Name}}GoalHandle) Accept() (*{{.Action.Name}}FeedbackSender, error) {
	s, err := g.GoalHandle.Accept()
	if err != nil {
		return nil, err
	}
	return &{{.Action.Name}}FeedbackSender{*s}, nil
}

type {{.Action.Name}}Action interface {
	ExecuteGoal(context.Context, *{{.Action.Name}}GoalHandle) (*{{.Action.Name}}_Result, error)
}

func New{{.Action.Name}}Action(
	executeGoal func(context.Context, *{{.Action.Name}}GoalHandle) (*{{.Action.Name}}_Result, error),
) {{.Action.Name}}Action {
	return _{{.Action.Name}}FuncAction(executeGoal)
}

type _{{.Action.Name}}FuncAction func(context.Context, *{{.Action.Name}}GoalHandle) (*{{.Action.Name}}_Result, error)

func (a _{{.Action.Name}}FuncAction) ExecuteGoal(
	ctx context.Context, goal *{{.Action.Name}}GoalHandle,
) (*{{.Action.Name}}_Result, error) {
	return a(ctx, goal)
}

type _{{.Action.Name}}Action struct {
	action {{.Action.Name}}Action
}

func (a _{{.Action.Name}}Action) ExecuteGoal(ctx context.Context, handle *{{ $.ROSDistro }}.GoalHandle) ({{ $.ROSDistro }}.Message, error) {
	return a.action.ExecuteGoal(ctx, &{{.Action.Name}}GoalHandle{
		GoalHandle:  handle,
		Description: handle.Description.(*{{.Action.Name}}_Goal),
	})
}

func (a _{{.Action.Name}}Action) TypeSupport() {{ $.ROSDistro }}.ActionTypeSupport {
	return {{.Action.Name}}TypeSupport
}

type {{.Action.Name}}Server struct{
	*{{ $.ROSDistro }}.ActionServer
}

func New{{.Action.Name}}Server(node *{{ $.ROSDistro }}.Node, name string, action {{.Action.Name}}Action, opts *{{ $.ROSDistro }}.ActionServerOptions) (*{{.Action.Name}}Server, error) {
	server, err := node.NewActionServer(name, _{{.Action.Name}}Action{action}, opts)
	if err != nil {
		return nil, err
	}
	return &{{.Action.Name}}Server{server}, nil
}

type {{.Action.Name}}FeedbackHandler func(context.Context, *{{.Action.Name}}_FeedbackMessage)

type {{.Action.Name}}StatusHandler func(context.Context, *action_msgs_msg.GoalStatus)

type {{.Action.Name}}Client struct{
	*{{ $.ROSDistro }}.ActionClient
}

func New{{.Action.Name}}Client(node *{{ $.ROSDistro }}.Node, name string, opts *{{ $.ROSDistro }}.ActionClientOptions) (*{{.Action.Name}}Client, error) {
	client, err := node.NewActionClient(name, {{.Action.Name}}TypeSupport, opts)
	if err != nil {
		return nil, err
	}
	return &{{.Action.Name}}Client{client}, nil
}

func (c *{{.Action.Name}}Client) WatchGoal(ctx context.Context, goal *{{.Action.Name}}_Goal, onFeedback {{.Action.Name}}FeedbackHandler) (*{{.Action.Name}}_GetResult_Response, *{{ $.ROSDistro }}.GoalID, error) {
	var resp {{ $.ROSDistro }}.Message
	var goalID *{{ $.ROSDistro }}.GoalID
	var err error
	if onFeedback == nil {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, nil)
	} else {
		resp, goalID, err = c.ActionClient.WatchGoal(ctx, goal, func(ctx context.Context, msg {{ $.ROSDistro }}.Message) {
			onFeedback(ctx, msg.(*{{.Action.Name}}_FeedbackMessage))
		})
	}
	if r, ok := resp.(*{{.Action.Name}}_GetResult_Response); ok {
		return r, goalID, err
	}
	return nil, goalID, err
}

func (c *{{.Action.Name}}Client) SendGoal(ctx context.Context, goal *{{.Action.Name}}_Goal) (*{{.Action.Name}}_SendGoal_Response, *{{ $.ROSDistro }}.GoalID, error) {
	resp, id, err := c.ActionClient.SendGoal(ctx, goal)
	if r, ok := resp.(*{{.Action.Name}}_SendGoal_Response); ok {
		return r, id, err
	}
	return nil, id, err
}

func (c *{{.Action.Name}}Client) SendGoalRequest(ctx context.Context, request *{{.Action.Name}}_SendGoal_Request) (*{{.Action.Name}}_SendGoal_Response, error) {
	resp, err := c.ActionClient.SendGoalRequest(ctx, request)
	if r, ok := resp.(*{{.Action.Name}}_SendGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *{{.Action.Name}}Client) GetResult(ctx context.Context, goalID *{{ $.ROSDistro }}.GoalID) (*{{.Action.Name}}_GetResult_Response, error) {
	resp, err := c.ActionClient.GetResult(ctx, goalID)
	if r, ok := resp.(*{{.Action.Name}}_GetResult_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *{{.Action.Name}}Client) CancelGoal(ctx context.Context, request *action_msgs_srv.CancelGoal_Request) (*action_msgs_srv.CancelGoal_Response, error) {
	resp, err := c.ActionClient.CancelGoal(ctx, request)
	if r, ok := resp.(*action_msgs_srv.CancelGoal_Response); ok {
		return r, err
	}
	return nil, err
}

func (c *{{.Action.Name}}Client) WatchFeedback(ctx context.Context, goalID *{{ $.ROSDistro }}.GoalID, handler {{.Action.Name}}FeedbackHandler) <-chan error {
	return c.ActionClient.WatchFeedback(ctx, goalID, func(ctx context.Context, msg {{ $.ROSDistro }}.Message) {
		handler(ctx, msg.(*{{.Action.Name}}_FeedbackMessage))
	})
}

func (c *{{.Action.Name}}Client) WatchStatus(ctx context.Context, goalID *{{ $.ROSDistro }}.GoalID, handler {{.Action.Name}}StatusHandler) <-chan error {
	return c.ActionClient.WatchStatus(ctx, goalID, func(ctx context.Context, msg {{ $.ROSDistro }}.Message) {
		handler(ctx, msg.(*action_msgs_msg.GoalStatus))
	})
}
`))

var primitiveTypes = template.Must(
	template.New("primitiveTypes").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.

package {{ $.ROSDistro }}

/*
{{range $rootPath := $.Config.RootPaths -}}
#cgo LDFLAGS: "-L{{$rootPath}}/lib" "-Wl,-rpath={{$rootPath}}/lib"
#cgo CFLAGS: "-I{{$rootPath}}/include/rosidl_runtime_c"
{{end}}
#cgo LDFLAGS: -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation

#include "rosidl_runtime_c/string.h"
#include "rosidl_runtime_c/primitives_sequence.h"
#include "rosidl_runtime_c/u16string.h"

*/
import "C"
import (
	"unicode/utf16"
	"unsafe"
	"strings"
)

func StringAsCStruct(dst unsafe.Pointer, m string) {
	mem := (*C.rosidl_runtime_c__String)(dst)
	mem.data = (*C.char)(C.malloc(C.sizeof_char * C.size_t(len(m)+1)))
	mem.size = C.size_t(len(m))
	mem.capacity = C.size_t(len(m) + 1)
	memData := unsafe.Slice((*byte)(unsafe.Pointer(mem.data)), mem.capacity)
	copy(memData, m)
	memData[len(memData)-1] = 0
}

func StringAsGoStruct(m *string, ros2MessageBuffer unsafe.Pointer) {
	mem := (*C.rosidl_runtime_c__String)(ros2MessageBuffer)
	sb := strings.Builder{}
	sb.Grow(int(mem.size))
	sb.Write(unsafe.Slice((*byte)(unsafe.Pointer(mem.data)), mem.size))
	*m = sb.String()
}

type CString = C.rosidl_runtime_c__String
type CStringSequence = C.rosidl_runtime_c__String__Sequence

func StringSequenceToGo(goSlice *[]string, cSlice CStringSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]string, int64(cSlice.size))
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := 0; i < int(cSlice.size); i++ {
		StringAsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func StringSequenceToC(cSlice *CStringSequence, goSlice []string) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rosidl_runtime_c__String)(C.malloc((C.size_t)(C.sizeof_struct_rosidl_runtime_c__String * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		StringAsCStruct(unsafe.Pointer(&dst[i]), goSlice[i])
	}
}

func StringArrayToGo(goSlice []string, cSlice []CString) {
	for i := 0; i < len(cSlice); i++ {
		StringAsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func StringArrayToC(cSlice []CString, goSlice []string) {
	for i := 0; i < len(goSlice); i++ {
		StringAsCStruct(unsafe.Pointer(&cSlice[i]), goSlice[i])
	}
}

type CChar = C.schar
type CcharSequence = C.rosidl_runtime_c__char__Sequence

func CharSequenceToGo(goSlice *[]byte, cSlice CcharSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]byte, cSlice.size)
	src := unsafe.Slice((*byte)(unsafe.Pointer(cSlice.data)), cSlice.size)
	copy(*goSlice, src)
}

func CharSequenceToC(cSlice *CcharSequence, goSlice []byte) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.schar)(C.malloc(C.sizeof_schar * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice((*byte)(unsafe.Pointer(cSlice.data)), cSlice.size)
	copy(dst, goSlice)
}

func CharArrayToGo(goSlice []byte, cSlice []CChar) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = byte(cSlice[i])
	}
}

func CharArrayToC(cSlice []CChar, goSlice []byte) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.schar(goSlice[i])
	}
}

func U16StringAsCStruct(dst unsafe.Pointer, m string) {
	// rosidl_runtime_c__U16String__assignn() does something like this,
	// but to call it we still need to make a C string and free it.
	mem := (*C.rosidl_runtime_c__U16String)(dst)
	runescape := utf16.Encode([]rune(m))

	mem.data = (*C.ushort)(C.malloc(C.sizeof_ushort * C.size_t(len(runescape)+1)))
	mem.size = C.size_t(len(runescape))
	mem.capacity = C.size_t(len(runescape) + 1)
	memData := unsafe.Slice((*uint16)(mem.data), mem.capacity)
	copy(memData, runescape)
	memData[len(memData)-1] = 0
}

func U16StringAsGoStruct(msg *string, ros2MessageBuffer unsafe.Pointer) {
	mem := (*C.rosidl_runtime_c__U16String)(ros2MessageBuffer)

	*msg = string(utf16.Decode(unsafe.Slice((*uint16)(mem.data), mem.size)))
}

type CU16String = C.rosidl_runtime_c__U16String
type Cu16stringSequence = C.rosidl_runtime_c__U16String__Sequence

func U16stringSequenceToGo(goSlice *[]string, cSlice Cu16stringSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]string, int64(cSlice.size))
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := 0; i < int(cSlice.size); i++ {
		U16StringAsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func U16stringSequenceToC(cSlice *Cu16stringSequence, goSlice []string) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rosidl_runtime_c__U16String)(C.malloc((C.size_t)(C.sizeof_struct_rosidl_runtime_c__U16String * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		U16StringAsCStruct(unsafe.Pointer(&dst[i]), goSlice[i])
	}
}

func U16stringArrayToGo(goSlice []string, cSlice []CU16String) {
	for i := 0; i < len(cSlice); i++ {
		U16StringAsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func U16stringArrayToC(cSlice []CU16String, goSlice []string) {
	for i := 0; i < len(goSlice); i++ {
		U16StringAsCStruct(unsafe.Pointer(&cSlice[i]), goSlice[i])
	}
}{{range $k, $v := .PMap -}}{{if .SkipAutogen}}{{- else -}}
{{""}}
{{""}}
// {{.RosType | ucFirst}}
type C{{.RosType | ucFirst}} = C.{{.CType}}
type C{{.RosType | ucFirst}}Sequence = C.rosidl_runtime_c__{{.CStructName}}__Sequence

func {{.RosType | ucFirst}}SequenceToGo(goSlice *[]{{.GoType}}, cSlice C{{.RosType | ucFirst}}Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{.GoType}}, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = {{.GoType}}(src[i])
	}
}

func {{.RosType | ucFirst}}SequenceToC(cSlice *C{{.RosType | ucFirst}}Sequence, goSlice []{{.GoType}}) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.{{.CType}})(C.malloc(C.sizeof_{{.CType}} * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.{{.CType}}(goSlice[i])
	}
}

func {{.RosType | ucFirst}}ArrayToGo(goSlice []{{.GoType}}, cSlice []C{{.RosType | ucFirst}}) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = {{.GoType}}(cSlice[i])
	}
}

func {{.RosType | ucFirst}}ArrayToC(cSlice []C{{.RosType | ucFirst}}, goSlice []{{.GoType}}) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.{{.CType}}(goSlice[i])
	}
}
{{- end}}{{- end}}
`),
)

var ros2MsgImportAllPackage = template.Must(
	template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.

package msgs

import (
	{{- range $import, $unused := .Packages }}
	_ "{{$.Config.MessageModulePrefix}}/{{$import}}" //
	{{- end }}
)
`),
)

//nolint:dupword
var ros2ErrorCodes = template.Must(
	template.New("ros2ErrorCodes").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.
{{ $P := . }}
package {{ $.ROSDistro }}

/*
{{- range $file := .includes }}
#include <{{$file}}>
{{- end }}
*/
import "C"
import (
	"runtime"
)

func errorsCastC(rclRetT C.rcl_ret_t, context string) error {
	stackTraceBuffer := make([]byte, 2048)
	runtime.Stack(stackTraceBuffer, false) // Get stack trace of the current running thread only

	switch rclRetT {
	{{range $e := .errorTypes -}}{{if $e.RclRetT -}}{{if not (index $P.dedupFilter $e.Name) -}}
	case C.{{$e.Name}}:
		return &{{$e.Name|cReturnCodeNameToGo}}{rclError: rclError{rclRetCode: {{$e.RclRetT}}, trace: string(stackTraceBuffer), context: errorsBuildContext(&{{$e.Name|cReturnCodeNameToGo}}{}, context, string(stackTraceBuffer))}}
	{{""}}
	{{- end}}{{- end}}{{- end}}
	default:
		return &UnknownReturnCode{rclError: rclError{rclRetCode: int(rclRetT), context: context}}
	}
}

type UnknownReturnCode struct {
	rclError
}

{{range $e := .errorTypes -}}{{if $e.RclRetT}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} struct {
	rclError
}
{{""}}
{{- end}}{{- end}}

{{range $e := .errorTypes -}}{{if $e.Reference}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} = {{$e.Reference|cReturnCodeNameToGo}}
{{""}}
{{- end}}{{- end}}

`),
)

var rclgoFlags = template.Must(
	template.New("rclgoFlags").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.

package {{ $.ROSDistro }}

/*
{{range $rootPath := $.Config.RootPaths -}}
#cgo LDFLAGS: "-L{{$rootPath}}/lib" "-Wl,-rpath={{$rootPath}}/lib"
{{range $dep := $.ROSIncludes -}}
#cgo CFLAGS: "-I{{$rootPath}}/include/{{$dep}}"
{{end}}
{{end -}}
#cgo LDFLAGS: -lrcl -lrmw -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrcl_action -lrmw_implementation
*/
import "C"
`),
)

var gogenTestFlags = template.Must(
	template.New("gogenTestFlags").Funcs(templateFuncMap).Parse(
		`// Code generated by ros2gen. DO NOT EDIT.

package test

/*
{{range $rootPath := $.Config.RootPaths -}}
#cgo LDFLAGS: "-L{{$rootPath}}/lib" "-Wl,-rpath={{$rootPath}}/lib"
#cgo CFLAGS: "-I{{$rootPath}}/include/builtin_interfaces"
#cgo CFLAGS: "-I{{$rootPath}}/include/rosidl_runtime_c"
#cgo CFLAGS: "-I{{$rootPath}}/include/rosidl_typesupport_interface"
#cgo CFLAGS: "-I{{$rootPath}}/include/sensor_msgs"
#cgo CFLAGS: "-I{{$rootPath}}/include/std_msgs"
#cgo CFLAGS: "-I{{$rootPath}}/include/test_msgs"

{{end -}}
#cgo LDFLAGS: -lrcl -lrcl_interfaces__rosidl_typesupport_c -lrcutils
#cgo LDFLAGS: -lrmw_implementation -lrosidl_runtime_c -lrosidl_typesupport_c
#cgo LDFLAGS: -lsensor_msgs__rosidl_generator_c -lsensor_msgs__rosidl_typesupport_c
#cgo LDFLAGS: -lstd_msgs__rosidl_generator_c -lstd_msgs__rosidl_typesupport_c
#cgo LDFLAGS: -ltest_msgs__rosidl_generator_c -ltest_msgs__rosidl_typesupport_c
*/
import "C"
`),
)
