// Code generated by ros2gen. DO NOT EDIT.

package humble

/*
#cgo LDFLAGS: "-L/opt/ros/humble/lib" "-Wl,-rpath=/opt/ros/humble/lib"
#cgo CFLAGS: "-I/opt/ros/humble/include/rosidl_runtime_c"

#cgo LDFLAGS: -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation

#include "rosidl_runtime_c/string.h"
#include "rosidl_runtime_c/primitives_sequence.h"
#include "rosidl_runtime_c/u16string.h"

*/
import "C"
import (
	"unicode/utf16"
	"unsafe"
	"strings"
)

func StringAsCStruct(dst unsafe.Pointer, m string) {
	mem := (*C.rosidl_runtime_c__String)(dst)
	mem.data = (*C.char)(C.malloc(C.sizeof_char * C.size_t(len(m)+1)))
	mem.size = C.size_t(len(m))
	mem.capacity = C.size_t(len(m) + 1)
	memData := unsafe.Slice((*byte)(unsafe.Pointer(mem.data)), mem.capacity)
	copy(memData, m)
	memData[len(memData)-1] = 0
}

func StringAsGoStruct(m *string, ros2MessageBuffer unsafe.Pointer) {
	mem := (*C.rosidl_runtime_c__String)(ros2MessageBuffer)
	sb := strings.Builder{}
	sb.Grow(int(mem.size))
	sb.Write(unsafe.Slice((*byte)(unsafe.Pointer(mem.data)), mem.size))
	*m = sb.String()
}

type CString = C.rosidl_runtime_c__String
type CStringSequence = C.rosidl_runtime_c__String__Sequence

func StringSequenceToGo(goSlice *[]string, cSlice CStringSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]string, int64(cSlice.size))
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := 0; i < int(cSlice.size); i++ {
		StringAsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func StringSequenceToC(cSlice *CStringSequence, goSlice []string) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rosidl_runtime_c__String)(C.malloc((C.size_t)(C.sizeof_struct_rosidl_runtime_c__String * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		StringAsCStruct(unsafe.Pointer(&dst[i]), goSlice[i])
	}
}

func StringArrayToGo(goSlice []string, cSlice []CString) {
	for i := 0; i < len(cSlice); i++ {
		StringAsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func StringArrayToC(cSlice []CString, goSlice []string) {
	for i := 0; i < len(goSlice); i++ {
		StringAsCStruct(unsafe.Pointer(&cSlice[i]), goSlice[i])
	}
}

type CChar = C.schar
type CcharSequence = C.rosidl_runtime_c__char__Sequence

func CharSequenceToGo(goSlice *[]byte, cSlice CcharSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]byte, cSlice.size)
	src := unsafe.Slice((*byte)(unsafe.Pointer(cSlice.data)), cSlice.size)
	copy(*goSlice, src)
}

func CharSequenceToC(cSlice *CcharSequence, goSlice []byte) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.schar)(C.malloc(C.sizeof_schar * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice((*byte)(unsafe.Pointer(cSlice.data)), cSlice.size)
	copy(dst, goSlice)
}

func CharArrayToGo(goSlice []byte, cSlice []CChar) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = byte(cSlice[i])
	}
}

func CharArrayToC(cSlice []CChar, goSlice []byte) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.schar(goSlice[i])
	}
}

func U16StringAsCStruct(dst unsafe.Pointer, m string) {
	// rosidl_runtime_c__U16String__assignn() does something like this,
	// but to call it we still need to make a C string and free it.
	mem := (*C.rosidl_runtime_c__U16String)(dst)
	runescape := utf16.Encode([]rune(m))

	mem.data = (*C.ushort)(C.malloc(C.sizeof_ushort * C.size_t(len(runescape)+1)))
	mem.size = C.size_t(len(runescape))
	mem.capacity = C.size_t(len(runescape) + 1)
	memData := unsafe.Slice((*uint16)(mem.data), mem.capacity)
	copy(memData, runescape)
	memData[len(memData)-1] = 0
}

func U16StringAsGoStruct(msg *string, ros2MessageBuffer unsafe.Pointer) {
	mem := (*C.rosidl_runtime_c__U16String)(ros2MessageBuffer)

	*msg = string(utf16.Decode(unsafe.Slice((*uint16)(mem.data), mem.size)))
}

type CU16String = C.rosidl_runtime_c__U16String
type Cu16stringSequence = C.rosidl_runtime_c__U16String__Sequence

func U16stringSequenceToGo(goSlice *[]string, cSlice Cu16stringSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]string, int64(cSlice.size))
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := 0; i < int(cSlice.size); i++ {
		U16StringAsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}

func U16stringSequenceToC(cSlice *Cu16stringSequence, goSlice []string) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.rosidl_runtime_c__U16String)(C.malloc((C.size_t)(C.sizeof_struct_rosidl_runtime_c__U16String * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		U16StringAsCStruct(unsafe.Pointer(&dst[i]), goSlice[i])
	}
}

func U16stringArrayToGo(goSlice []string, cSlice []CU16String) {
	for i := 0; i < len(cSlice); i++ {
		U16StringAsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}

func U16stringArrayToC(cSlice []CU16String, goSlice []string) {
	for i := 0; i < len(goSlice); i++ {
		U16StringAsCStruct(unsafe.Pointer(&cSlice[i]), goSlice[i])
	}
}

// Bool
type CBool = C.bool
type CBoolSequence = C.rosidl_runtime_c__boolean__Sequence

func BoolSequenceToGo(goSlice *[]bool, cSlice CBoolSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]bool, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = bool(src[i])
	}
}

func BoolSequenceToC(cSlice *CBoolSequence, goSlice []bool) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.bool)(C.malloc(C.sizeof_bool * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.bool(goSlice[i])
	}
}

func BoolArrayToGo(goSlice []bool, cSlice []CBool) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = bool(cSlice[i])
	}
}

func BoolArrayToC(cSlice []CBool, goSlice []bool) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.bool(goSlice[i])
	}
}

// Byte
type CByte = C.uint8_t
type CByteSequence = C.rosidl_runtime_c__octet__Sequence

func ByteSequenceToGo(goSlice *[]byte, cSlice CByteSequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]byte, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = byte(src[i])
	}
}

func ByteSequenceToC(cSlice *CByteSequence, goSlice []byte) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.uint8_t)(C.malloc(C.sizeof_uint8_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.uint8_t(goSlice[i])
	}
}

func ByteArrayToGo(goSlice []byte, cSlice []CByte) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = byte(cSlice[i])
	}
}

func ByteArrayToC(cSlice []CByte, goSlice []byte) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.uint8_t(goSlice[i])
	}
}

// Float32
type CFloat32 = C.float
type CFloat32Sequence = C.rosidl_runtime_c__float__Sequence

func Float32SequenceToGo(goSlice *[]float32, cSlice CFloat32Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]float32, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = float32(src[i])
	}
}

func Float32SequenceToC(cSlice *CFloat32Sequence, goSlice []float32) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.float)(C.malloc(C.sizeof_float * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.float(goSlice[i])
	}
}

func Float32ArrayToGo(goSlice []float32, cSlice []CFloat32) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = float32(cSlice[i])
	}
}

func Float32ArrayToC(cSlice []CFloat32, goSlice []float32) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.float(goSlice[i])
	}
}

// Float64
type CFloat64 = C.double
type CFloat64Sequence = C.rosidl_runtime_c__double__Sequence

func Float64SequenceToGo(goSlice *[]float64, cSlice CFloat64Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]float64, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = float64(src[i])
	}
}

func Float64SequenceToC(cSlice *CFloat64Sequence, goSlice []float64) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.double)(C.malloc(C.sizeof_double * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.double(goSlice[i])
	}
}

func Float64ArrayToGo(goSlice []float64, cSlice []CFloat64) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = float64(cSlice[i])
	}
}

func Float64ArrayToC(cSlice []CFloat64, goSlice []float64) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.double(goSlice[i])
	}
}

// Int16
type CInt16 = C.int16_t
type CInt16Sequence = C.rosidl_runtime_c__int16__Sequence

func Int16SequenceToGo(goSlice *[]int16, cSlice CInt16Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]int16, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = int16(src[i])
	}
}

func Int16SequenceToC(cSlice *CInt16Sequence, goSlice []int16) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.int16_t)(C.malloc(C.sizeof_int16_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.int16_t(goSlice[i])
	}
}

func Int16ArrayToGo(goSlice []int16, cSlice []CInt16) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = int16(cSlice[i])
	}
}

func Int16ArrayToC(cSlice []CInt16, goSlice []int16) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.int16_t(goSlice[i])
	}
}

// Int32
type CInt32 = C.int32_t
type CInt32Sequence = C.rosidl_runtime_c__int32__Sequence

func Int32SequenceToGo(goSlice *[]int32, cSlice CInt32Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]int32, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = int32(src[i])
	}
}

func Int32SequenceToC(cSlice *CInt32Sequence, goSlice []int32) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.int32_t)(C.malloc(C.sizeof_int32_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.int32_t(goSlice[i])
	}
}

func Int32ArrayToGo(goSlice []int32, cSlice []CInt32) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = int32(cSlice[i])
	}
}

func Int32ArrayToC(cSlice []CInt32, goSlice []int32) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.int32_t(goSlice[i])
	}
}

// Int64
type CInt64 = C.int64_t
type CInt64Sequence = C.rosidl_runtime_c__int64__Sequence

func Int64SequenceToGo(goSlice *[]int64, cSlice CInt64Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]int64, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = int64(src[i])
	}
}

func Int64SequenceToC(cSlice *CInt64Sequence, goSlice []int64) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.int64_t)(C.malloc(C.sizeof_int64_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.int64_t(goSlice[i])
	}
}

func Int64ArrayToGo(goSlice []int64, cSlice []CInt64) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = int64(cSlice[i])
	}
}

func Int64ArrayToC(cSlice []CInt64, goSlice []int64) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.int64_t(goSlice[i])
	}
}

// Int8
type CInt8 = C.int8_t
type CInt8Sequence = C.rosidl_runtime_c__int8__Sequence

func Int8SequenceToGo(goSlice *[]int8, cSlice CInt8Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]int8, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = int8(src[i])
	}
}

func Int8SequenceToC(cSlice *CInt8Sequence, goSlice []int8) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.int8_t)(C.malloc(C.sizeof_int8_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.int8_t(goSlice[i])
	}
}

func Int8ArrayToGo(goSlice []int8, cSlice []CInt8) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = int8(cSlice[i])
	}
}

func Int8ArrayToC(cSlice []CInt8, goSlice []int8) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.int8_t(goSlice[i])
	}
}

// Uint16
type CUint16 = C.uint16_t
type CUint16Sequence = C.rosidl_runtime_c__uint16__Sequence

func Uint16SequenceToGo(goSlice *[]uint16, cSlice CUint16Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]uint16, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = uint16(src[i])
	}
}

func Uint16SequenceToC(cSlice *CUint16Sequence, goSlice []uint16) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.uint16_t)(C.malloc(C.sizeof_uint16_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.uint16_t(goSlice[i])
	}
}

func Uint16ArrayToGo(goSlice []uint16, cSlice []CUint16) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = uint16(cSlice[i])
	}
}

func Uint16ArrayToC(cSlice []CUint16, goSlice []uint16) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.uint16_t(goSlice[i])
	}
}

// Uint32
type CUint32 = C.uint32_t
type CUint32Sequence = C.rosidl_runtime_c__uint32__Sequence

func Uint32SequenceToGo(goSlice *[]uint32, cSlice CUint32Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]uint32, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = uint32(src[i])
	}
}

func Uint32SequenceToC(cSlice *CUint32Sequence, goSlice []uint32) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.uint32_t)(C.malloc(C.sizeof_uint32_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.uint32_t(goSlice[i])
	}
}

func Uint32ArrayToGo(goSlice []uint32, cSlice []CUint32) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = uint32(cSlice[i])
	}
}

func Uint32ArrayToC(cSlice []CUint32, goSlice []uint32) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.uint32_t(goSlice[i])
	}
}

// Uint64
type CUint64 = C.uint64_t
type CUint64Sequence = C.rosidl_runtime_c__uint64__Sequence

func Uint64SequenceToGo(goSlice *[]uint64, cSlice CUint64Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]uint64, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = uint64(src[i])
	}
}

func Uint64SequenceToC(cSlice *CUint64Sequence, goSlice []uint64) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.uint64_t)(C.malloc(C.sizeof_uint64_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.uint64_t(goSlice[i])
	}
}

func Uint64ArrayToGo(goSlice []uint64, cSlice []CUint64) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = uint64(cSlice[i])
	}
}

func Uint64ArrayToC(cSlice []CUint64, goSlice []uint64) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.uint64_t(goSlice[i])
	}
}

// Uint8
type CUint8 = C.uint8_t
type CUint8Sequence = C.rosidl_runtime_c__uint8__Sequence

func Uint8SequenceToGo(goSlice *[]uint8, cSlice CUint8Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]uint8, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		(*goSlice)[i] = uint8(src[i])
	}
}

func Uint8SequenceToC(cSlice *CUint8Sequence, goSlice []uint8) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.uint8_t)(C.malloc(C.sizeof_uint8_t * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		dst[i] = C.uint8_t(goSlice[i])
	}
}

func Uint8ArrayToGo(goSlice []uint8, cSlice []CUint8) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = uint8(cSlice[i])
	}
}

func Uint8ArrayToC(cSlice []CUint8, goSlice []uint8) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.uint8_t(goSlice[i])
	}
}
